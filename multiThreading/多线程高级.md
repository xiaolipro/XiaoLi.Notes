## 一、Monitor的Wait/Pulse

**信号构造本质：一个线程阻塞直到收到另一个线程发来的通知。**

#### **模拟信号构造**

1. 定义一个字段，作为同步对象

   ```c#
   private readonly object _locker = new object();
   ```

2. 定义一个或多个字段，作为阻塞条件

   ```c#
   private bool _ok;
   ```

3. 当你希望阻塞的时候

   `Monitor.Wait`在等待脉冲时，同步对象上的锁会被释放，并且进入阻塞状态，直到收到 _locker上的脉冲，收到脉冲后重新获取  _locker，如果此时 _locker 已经被别的线程占有，则继续阻塞，直至_获取 _locker

   ```c#
   lock (_locker) 
   {
       while (!_ok)
       {
           Monitor.Wait (_locker);
       }
   }
   ```

4. 当你希望改变阻塞条件时

   ```c#
   lock (_locker)
   {
       _ok = true;
       Monitor.Pulse(_locker);  // Monitor.PulseAll(_locker);
   }
   ```

   

通过一个bool标识我们就能实现AutoResetEvent/ManualResetEvent的功能，同理使用一个整形字段，就可以实现CountdownEvent/Semaphore



#### 生产消费队列

```c#
public class PCQueue: IDisposable
{
    private readonly object _locker = new object();
    private Thread[] _workers;
    private Queue<Action> _queue = new Queue<Action>();
    
    private readonly ITestOutputHelper _testOutputHelper;
    public PCQueue(ITestOutputHelper testOutputHelper, int workerCount)
    {
        _testOutputHelper = testOutputHelper;
        _workers = new Thread[workerCount];
        for (int i = 0; i < workerCount; i++)
        {
            _workers[i] = new Thread(Consume);
            _workers[i].Start();
        }
    }
    public void AddTask(Action task)
    {
        lock (_locker)
        {
            _queue.Enqueue(task);
            Monitor.Pulse(_locker);
        }
    }
    private void Consume()
    {
        while (true)
        {
            Action task;
            lock (_locker)
            {
                while (_queue.Count == 0)
                {
                    Monitor.Wait(_locker);  // 队列里没任务，释放锁，进入等待
                }
                // 获取新任务，重新持有锁
                task = _queue.Dequeue();
            }
            
            if (task == null) return;  // 空任务代表退出
            task();  // 执行任务
        }
    }
    public void Dispose()
    {
        foreach (var worker in _workers)
        {
            AddTask(null);
        }
        
        foreach (var worker in _workers)
        {
            worker.Join();
        }
    }
}
```

出于效率考虑，加入一个任务时，我们调用`Pulse`而不是`PulseAll`。这是因为每个项目只需要唤醒（至多）一个消费者。如果你只有一个冰激凌，你不会把一个班 30 个正在睡觉的孩子都叫起来排队获取它。
## 一、非阻塞同步

#### 前言

抛开死锁不谈，只聊性能问题，尽管锁总能粗暴的满足同步需求，但一旦存在竞争关系，意味着一定会有线程被阻塞，竞争越激烈，被阻塞的线程越多，上下文切换次数越多，调度成本越大，显然在高并发的场景下会损害性能。在高并发高性能且要求线程安全的述求下，无锁构造（非阻塞构造）闪亮登场。

#### 重排序与缓存

我们观察下面这个例子：

```c#
public class Foo
{
    private int _answer;
    private bool _complete;

    void A()
    {
        _answer = 10;
        _complete = true;
    }

    void B()
    {
        if (_complete) Console.WriteLine(_answer);
    }
}
```

如果方法`A`和`B`在不同的线程上并发运行，`B`可能会打印 “ 0 “ 吗？答案是会的，原因如下：

- 编译器、CLR 或 CPU 可能会对代码/指令进行**重排序（reorder）**以提高效率。
- 编译器、CLR 或 CPU 可能会进行**缓存**优化，导致其它线程不能马上看到变量的新值。

**请务必重视它们，它们将是幽灵般的存在**

```c#
int x = 0, y = 0, a = 0, b = 0;

var task1 = Task.Run(() => // A
{
    a = 1; // 1
    x = b; // 2
});
var task2 = Task.Run(() => // B
{
    b = 2; // 3
    y = a; // 4
});
Task.WaitAll(task1, task2);
Console.WriteLine("x:" + x + " y:" + y);
```

直觉和经验告诉我们，程序至顶向下执行：代码1一定发生在代码2之前，代码3一定发生在代码4之前，然鹅

在一个独立的线程中，每一个语句的执行顺序是可以被保证的，但在不使用lock，waithandle这样的显式同步操作时，我们就没法保证事件在不同的线程中看到的执行顺序是一致的了。尽管线程A中一定需要观察到a=1执行成功之后才会去执行x=b，但它没法确保自己观察得到线程B中对b的写入，所以A还可能会打印出y的一个旧版的值。这就叫指令重排序。

```shell
x:0 y:1 #1-2-3-4
x:2 y:0 #3-4-1-2
x:2 y:1 #1-3-2-4
```

可实际运行时还是有些让我们惊讶的情况：

```shell
x:0 y:0 #??
```

这就是缓存问题，如果两个线程在不同的CPU上执行，每一个核心有自己的缓存，这样一个线程的写入对于其它线程，在主存同步之前就是不可见的了。

> C#编译器和CLR运行时会非常小心的保证上述优化不会破坏普通的单线程代码，和正确使用锁的多线程代码。但有时，你仍然需要通过显示的创建**内存屏障（memory barrier，也称作内存栅栏 （memory fence））**来对抗这些优化，限制指令重排序和读写缓存产生的影响。

#### 内存屏障

处理器支持哪种内存重排序（LoadLoad重排序、LoadStore重排序、StoreStore重排序、StoreLoad重排序），就会提供相对应能够禁止重排序的指令，而这些指令就被称之为**内存屏障**（LoadLoad屏障、LoadStore屏障、StoreStore屏障、StoreLoad屏障）

|  屏障名称  | 示例                                                     | 具体作用                                                     |
| :--------: | -------------------------------------------------------- | ------------------------------------------------------------ |
| StoreLoad  | Store1;Store2;Store3;**StoreLoad**;Load1;Load2;Load3     | 禁止StoreLoad重排序，确保屏障之前任何一个写（如Store2）的结果都会在屏障后任意一个读操作（如Load1）加载之前被写入 |
| StoreStore | Store1;Store2;Store3;**StoreStore**;Store4;Store5;Store6 | 禁止StoreStore重排序，确保屏障之前任何一个写（如Store1）的结果都会在屏障后任意一个写操作（如Store4）之前被写入 |
|  LoadLoad  | Load1;Load2;Load3;**LoadLoad**;Load4;Load5;Load6         | 禁止LoadLoad重排序，确保屏障之前任何一个读（如Load1）的数据都会在屏障后任意一个读操作（如Load4）之前被加载 |
| LoadStore  | Load1;Load2;Load3;**LoadStore**;Store1;Store2;Store3     | 禁止LoadStore重排序，确保屏障之前任何一个读（如Load1）的数据都会在屏障后任意一个写操作（如Store1）的结果被写入高速缓存（或主内存）前被加载 |

读屏障告诉处理器在执行任何的加载前，执行所有已经在失效队列（Invalidte Queues）中的失效（I）指令。即：所有load barrier之前的store指令对之后（本核心和其他核心）的指令都是可见的。

Store Memory Barrier：写屏障，等同于前文的StoreStore Barriers 将store buffer都写入缓存。

写屏障告诉处理器在执行这之后的指令之前，执行所有已经在存储缓存（store buffer）中的修改（M）指令。即：所有store barrier之前的修改（M）指令都是对之后的指令可见。

最简单的内存屏障是**完全内存屏障（full memory barrier，或全栅栏（full fence））**，它可以阻止所有跨越栅栏的指令进行重排并`提交修改和刷新缓存`。

内存屏障之前的所有写操作都要写入内存，并将内存中的新值刷到缓存，使得其它CPU核心能够读取到最新值，进而解决CPU缓存带来的可见性问题。

我们简单修改一下前面的案例

```c#
void A()
{
    _answer = 10;
    Thread.MemoryBarrier(); // 1
    _complete = true;
    Thread.MemoryBarrier(); // 2
}
void B()
{
    Thread.MemoryBarrier(); // 3
    if (_complete)
    {
        _testOutputHelper.WriteLine(_answer.ToString());
    }
}
```

屏障1和屏障3使得这个例子不可能打印出0，屏障2保证如果B在A之后执行，_complete一定读到的是true

**内存屏障离我们并不遥远**，以下方式都会隐式的使用全栅栏：

- lock语法糖

- `Monitor.Enter` / `Monitor.Exit`

- `Interlocked`类中的所有方法

- 使用线程池的异步回调，包括异步委托，APM回调，以及任务延续（task continuations）

- 信号构造的等待/复位

- 任何依赖信号同步的情况，比如启动或等待Task，因此下面的代码也是线程安全的

  ```c#
  int x = 0;
  Task t = Task.Factory.StartNew (() => x++);
  t.Wait();
  Console.WriteLine (x);    // 1
  ```

#### 易失性

另一个（更高级的）解决这个问题的方法是对`_complete`字段使用`volatile`关键字。

```c#
volatile bool _complete;
```

`volatile`关键字通知编译器在每个读这个字段的地方使用一个读栅栏（acquire-fence），并且在每个写这个字段的地方使用一个写栅栏（release-fence）。

这种“半栅栏（half-fences）”比全栅栏更快，因为它给了运行时和硬件更大的优化空间。

> 巧的是，Intel 的 X86 和 X64 处理器总是在读时使用读栅栏，写时使用写栅栏，无论是否使用`volatile`关键字。所以在使用这些处理器的情况下，这个关键字对硬件来说是无效的。然而，`volatile`关键字对编译器和 CLR 进行的优化是有作用的，以及在 64 位 AMD 和 Itanium 处理器上也是有作用的。这意味着不能因为你的客户端运行在特定类型的 CPU 上而放松警惕。

注意：使用`volatile`不能阻止写-读被交换

| 第一条指令 | 第二条指令 | 是否会被交换                                                 |
| :--------- | :--------- | :----------------------------------------------------------- |
| 读         | 读         | 不会                                                         |
| 读         | 写         | 不会                                                         |
| 写         | 写         | 不会（CLR 确保写-写操作永远不会被交换，就算是没有`volatile`关键字） |
| 写         | 读         | **会！**                                                     |

在下面案例中仍然有可能会打印00的情况（对a的读取可能发生在写入前--重排序）

```c#
int a = 0, b = 0;
int x = 0, y = 0;
var task1 = Task.Run(() =>
{
    Thread.VolatileWrite(ref a, 1);
    x = Thread.VolatileRead(ref b);
});
var task2 = Task.Run(() =>
{
    Thread.VolatileWrite(ref b, 2);
    y = Thread.VolatileRead(ref a);
});
Task.WaitAll(task1, task2);

Console.WriteLine("x:" + x + " y:" + y);
```

`volatile`关键字不支持引用类型的参数和捕获的局部变量：这些情况下你必须使用`VolatileRead`和`VolatileWrite`方法

从上面的例子我们可以看出，读写



## 二、Lazy

面试时候经常问：**单例模式中的懒汉模式线程安全问题**

场景：某个字段构造开销非常大，使得在初始化`A`时需要承担初始化`Expensive`的开销，即使Expensive字段不会被用到。

```c#
public class A
{
    public readonly Expensive Expensive = new Expensive();
    // ..
}

public class Expensive
{
    // 构造开销非常昂贵
}
```

自然会想到懒汉模式：按需加载

```c#
public class B
{
    private Expensive _expensive;

    public Expensive GetExpensiveInstance()
    {
        if (_expensive == null) _expensive = new Expensive();

        return _expensive;
    }
}
```

新的问题产生：`GetExpensiveInstance`是线程安全的吗？我们可以通过加锁解决

```c#
public class C
{
    private readonly object _locker = new object();
    private Expensive _expensive;

    public Expensive GetExpensiveInstance()
    {
        lock (_locker)
        {
            if (_expensive == null) _expensive = new Expensive();
            return _expensive;
        }
    }
}
```

现在面试官继续问：还有性能更好的版本吗？..

net standard1.0 提供`System.Lazy<T>`来帮助你以线程安全且高效的方式（DCL）解决延迟初始化问题，只需

```c#
public class D
{
    private Lazy<Expensive> _expensive = new Lazy<Expensive>(() => new Expensive(), true);

    public Expensive GetExpensiveInstance() => _expensive.Value;
}
```





## 三、Monitor的Wait/Pulse

**信号构造本质：一个线程阻塞直到收到另一个线程发来的通知。**

#### **模拟信号构造**

1. 定义一个字段，作为同步对象

   ```c#
   private readonly object _locker = new object();
   ```

2. 定义一个或多个字段，作为阻塞条件

   ```c#
   private bool _ok;
   ```

3. 当你希望阻塞的时候

   `Monitor.Wait`在等待脉冲时，同步对象上的锁会被释放，并且进入阻塞状态，直到收到 _locker上的脉冲，收到脉冲后重新获取  _locker，如果此时 _locker 已经被别的线程占有，则继续阻塞，直至_获取 _locker

   ```c#
   lock (_locker) 
   {
       while (!_ok)
       {
           Monitor.Wait (_locker);
       }
   }
   ```

4. 当你希望改变阻塞条件时

   ```c#
   lock (_locker)
   {
       _ok = true;
       Monitor.Pulse(_locker);  // Monitor.PulseAll(_locker);
   }
   ```

   

通过一个bool标识我们就能实现AutoResetEvent/ManualResetEvent的功能，同理使用一个整形字段，就可以实现CountdownEvent/Semaphore



#### 生产消费队列

```c#
public class PCQueue: IDisposable
{
    private readonly object _locker = new object();
    private Thread[] _workers;
    private Queue<Action> _queue = new Queue<Action>();
    
    private readonly ITestOutputHelper _testOutputHelper;
    public PCQueue(ITestOutputHelper testOutputHelper, int workerCount)
    {
        _testOutputHelper = testOutputHelper;
        _workers = new Thread[workerCount];
        for (int i = 0; i < workerCount; i++)
        {
            _workers[i] = new Thread(Consume);
            _workers[i].Start();
        }
    }
    public void AddTask(Action task)
    {
        lock (_locker)
        {
            _queue.Enqueue(task);
            Monitor.Pulse(_locker);
        }
    }
    private void Consume()
    {
        while (true)
        {
            Action task;
            lock (_locker)
            {
                while (_queue.Count == 0)
                {
                    Monitor.Wait(_locker);  // 队列里没任务，释放锁，进入等待
                }
                // 获取新任务，重新持有锁
                task = _queue.Dequeue();
            }
            
            if (task == null) return;  // 空任务代表退出
            task();  // 执行任务
        }
    }
    public void Dispose()
    {
        foreach (var worker in _workers)
        {
            AddTask(null);
        }
        
        foreach (var worker in _workers)
        {
            worker.Join();
        }
    }
}
```

出于效率考虑，加入一个任务时，我们调用`Pulse`而不是`PulseAll`。这是因为每个项目只需要唤醒（至多）一个消费者。如果你只有一个冰激凌，你不会把一个班 30 个正在睡觉的孩子都叫起来排队获取它。
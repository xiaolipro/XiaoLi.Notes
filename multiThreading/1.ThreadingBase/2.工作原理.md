
## 工作原理

### 硬件结构
https://xiaolincoding.com/os/1_hardware/how_cpu_run.html#%E5%9B%BE%E7%81%B5%E6%9C%BA%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F


### 运行时

&emsp;&emsp;线程在内部由一个 **线程调度器（thread scheduler）** 管理，一般 CLR 会把这个任务交给操作系统完成。线程调度器确保所有活动的线程能够分配到适当的执行时间，
并且保证那些处于等待或阻塞状态（例如，等待排它锁或者用户输入）的线程不消耗CPU时间。

&emsp;&emsp;在单核计算机上，线程调度器会进行 **时间切片（time-slicing）** ，快速的在活动线程中切换执行。在 Windows 操作系统上，一个时间片通常在十几毫秒（译者注：默认 15.625ms），远大于 CPU 在线程间进行上下文切换的开销（通常在几微秒区间）。

&emsp;&emsp;在多核计算机上，多线程的实现是混合了时间切片和 **真实的并发（genuine concurrency）** ，不同的线程同时运行在不同的 CPU 核心上。仍然会使用到时间切片，因为操作系统除了要调度其它的应用，还需要调度自身的线程。

&emsp;&emsp;线程的执行由于外部因素（比如时间切片）被中断称为 **被抢占（preempted）**。在大多数情况下，线程无法控制其在什么时间，什么代码块被抢占。


> &emsp;&emsp;多线程同样也会带来缺点，最大的问题在于它提高了程序的复杂度。使用多个线程本身并不复杂，复杂的是线程间的交互（共享数据）如何保证安全。无论线程间的交互是否有意为之，都会带来较长的开发周期，以及带来间歇的、难以重现的 bug。因此，最好保证线程间的交互尽可能少，并坚持简单和已被证明的多线程交互设计。
>
> &emsp;&emsp;当频繁地调度和切换线程时（且活动线程数量大于 CPU 核心数），多线程会增加系统资源和 CPU 的开销，线程的创建和销毁也会增加开销。多线程并不总是能提升程序的运行速度，如果使用不当，反而可能降低速度。

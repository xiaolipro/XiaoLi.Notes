
## 基础操作

### 创建与启动

使用Thread类的构造方法来创建线程，支持以下两种委托
```c#
public delegate void ThreadStart();

public delegate void ParameterizedThreadStart (object? obj);
```

关于Thread构造重载方法参数 maxStackSize，不建议使用

https://stackoverflow.com/questions/5507574/maximum-thread-stack-size-net

```c#
public void 创建一个线程()
{
    var t = new Thread(Go);  // 开一个线程t
    t.Start();  // 启动t线程，执行Go方法
    
    Go();  // 主线程执行Go方法
}

void Go()
{
    _testOutputHelper.WriteLine("hello world!");
}
```

每一个线程都有一个 Name 属性，我们可以设置它以便于调试。线程的名字只能设置一次，再次修改会抛出异常。
```c#
public void 线程命名()
{
    var t = new Thread(Go);  // 开一个线程t
    t.Name = "worker";
    t.Start();  // 启动t线程，执行Go方法
    
    Go();  // 主线程执行Go方法
}

void Go()
{
    // Thread.CurrentThread属性会返回当前执行的线程
    _testOutputHelper.WriteLine(Thread.CurrentThread.Name + " say: hello!");
}
```

### 传递参数

Thread类的Start方法重载支持向thread实例传参
```c#
public void Start(object? parameter)
```
参数被lambda表达式捕获，传递给Go方法
```c#
public void 创建一个线程()
{
    var t = new Thread(msg => Go(msg));  // 开一个线程t
    t.Start("hello world!");  // 启动t线程，执行Go方法
    
    Go("main thread say：hello world!");  // 主线程执行Go方法
}

void Go(object? msg)
{
    _testOutputHelper.WriteLine(msg?.ToString());
}
```

请务必注意，不要在启动线程之后误修改被捕获变量（captured variables）
```c#
public void 闭包问题()
{
    for (int i = 0; i < 10; i++)
    {
        new Thread (() => Go(i)).Start();
    }
}
```

### 异常处理

当线程开始运行后，其内部发生的异常不会抛到外面，更不会被外面的try-catch-finally块捕获到。
```c#
void 异常捕获()
{
    try
    {
        new Thread(Go).Start();  // 启动t线程，执行Go方法
    }
    catch (Exception e)
    {
        _testOutputHelper.WriteLine(e.Message);
    }
}
    
void Go() => throw null!;  // 抛出空指针异常
```
解决方案是将异常处理移到Go方法中：自己的异常，自己解决
```c#
static void Go()
{
  try
  {
    // ...
    throw null;    // 异常会在下面被捕获
    // ...
  }
  catch (Exception ex)
  {
    // 一般会记录异常，或通知其它线程我们遇到问题了
    // ...
  }
}
```

AppDomain.CurrentDomain.UnhandledException 会对所有未处理的异常触发，因此它可以用于集中记录线程发生的异常，但是它不能阻止程序退出。
```c#
void UnhandledException()
{
    AppDomain.CurrentDomain.UnhandledException += HandleUnHandledException;
    new Thread(Go).Start();  // 启动t线程，执行Go方法
}

void HandleUnHandledException(object sender, UnhandledExceptionEventArgs eventArgs)
{
    _testOutputHelper.WriteLine("我发现异常了");
}
```

并非所有线程上的异常都需要处理，以下情况，.NET Framework 会为你处理：
+ 异步委托
+ BackgroundWorker
+ 任务并行库（TPL）

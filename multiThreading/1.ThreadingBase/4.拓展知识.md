## 拓展知识

### 线程优先级
线程的Priority属性决定了相对于操作系统中的其它活动线程，它可以获得多少CPU **时间片（time slice）**。

优先级依次递增，在提升线程优先级前请三思，这可能会导致其它线程的 **资源饥饿（resource starvation）**
```c#
enum ThreadPriority { Lowest, BelowNormal, Normal, AboveNormal, Highest }
```
提升线程的优先级并不等于直接优先，因为线程还受进程优先级影响，因此还需要使用System.Diagnostics中的Process类
```c#
using (Process p = Process.GetCurrentProcess())
{
    p.PriorityClass = ProcessPriorityClass.High;
}
```

ProcessPriorityClass.High是一个略低于最高优先级Realtime的级别。将一个进程的优先级设置为Realtime是通知操作系统，我们绝不希望该进程将 CPU 时间出让给其它进程。
如果你的程序误入一个死循环，会发现甚至是操作系统也被锁住了，就只好去按电源按钮了o(>_<)o　正是由于这一原因，High 通常是实时程序的最好选择。


### 前台线程与后台线程

**默认情况**下，**显式创建**的线程都是前台线程（foreground threads）。只要有一个前台线程在运行，程序就可以保持存活不结束。
当一个程序中所有前台线程停止运行时，仍在运行的所有后台线程会被强制终止。

> 这里说的 显示创建，指的是通过new Thread()创建的线程
>
> 非默认情况，指的是将Thread的IsBackground属性设置为true
> ```c#
> static void Main (string[] args)
> {
>      Thread worker = new Thread ( () => Console.ReadLine() );
>      if (args.Length > 0) worker.IsBackground = true;
>      worker.Start();
> }
> ```

当进程以强制终止这种方式结束时，后台线程执行栈中所有finally块就会被避开。如果程序依赖finally（或是using）块来执行清理工作，例如释放数据库/网络连接或是删除临时文件，就可能会产生问题。
为了避免这种问题，在退出程序时可以显式的等待这些后台线程结束。有两种方法可以实现：

+ 如果是显式创建的线程，在线程上调用Join阻塞。
+ 如果是使用线程池线程，使用信号构造，如事件等待句柄。

在任何一种情况下，都应指定一个超时时间，从而可以放弃由于某种原因而无法正常结束的线程。这是后备的退出策略：我们希望程序最后可以关闭，而不是让用户去开任务管理器(╯-_-)╯╧══╧

> 线程的 前台/后台状态 与它的 优先级/执行时间的分配无关。
>
### windows中通过任务管理器，linux中通过kill去杀掉一个进程，其资源是否会释放？

会。进程的特征之一就是动态性，其生存周期就是产生到消亡。当发生进程终止后，调用进程终止原语，从PCB总链中将其删除，将PCB结构归还给系统，释放该进程的资源给其父进程或者操作系统。

但不完全会。如果用户强行终止了.NET 进程，所有线程都会被当作后台线程一般丢弃

Process类有以下两种方法：
+ CloseMainWindow：向主窗口消息循环发送wm_quit消息以请求关闭进程，这使程序有机会重新调用其子窗口和内核对象。
+ Kill：强制终止进程，就像在任务管理器中终止进程一样。

我们可以使用visual studio组件：内存分析器 分析发现几乎在所有情况下，kill速度更快，但通过检查实时内存图可以发现其“根引用”和“实例引用”释放的内存更少。

### 什么是进程退出？

进程退出一般出现在以下几种情况：

+ 正常退出，进程执行完任务。

+ 错误退出，进程遇到不可继续运行的错误（发生异常未捕获导致程序退出）

+ 被操作系统终止，进程本身有问题，比如进程企图访问不属于自己的内存地址

+ 被其它进程终止，比如通过资源管理器我们可以选择终止掉某个进程

以上只有前两种情况是进程自愿退出的，因此，总体上可以分为三类：进程自愿退出，操作系统终止进程以及进程终止进程。

> main()执行结束时会自动隐式调用exit()，windows下叫ExitProcess。中止整个程序的执行，把控制返还给操作系统，并返回一个整数值，通常0表示正常终止，非0表示异常终止，这个值将会返回给操作系统。
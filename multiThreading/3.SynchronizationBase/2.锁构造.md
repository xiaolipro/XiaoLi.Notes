
## 锁构造

### Monitor
C# 的lock语句是一个语法糖，它其实就是使用了try / finally来调用Monitor.Enter与Monitor.Exit方法：
```c#
bool taken = false;
try
{
    // JIT应该内联此方法，以便在典型情况下优化lockTaken参数的检查。
    Monitor.Enter(_locker,ref taken);
    num++;
}
finally
{
    // C# 4.0 解决锁泄露问题
    if (taken) Monitor.Exit(_locker);
}
```
Monitor是【可重入的（Reentrant）】,只有当最外层的lock语句退出或是执行了匹配数目的Monitor.Exit语句时，对象才会被解锁。
```c#
static void Main()
{
    lock (locker)  // 线程只会在第一个（最外层）lock处阻塞。
    {
        AnotherMethod();
        // 这里依然拥有锁，因为锁是可重入的
    }
}

static void AnotherMethod()
{
  lock (_locker) { Console.WriteLine ("Another method"); }
}
```
&emsp;&emsp;Monitor的性能：在一个 2010 时代的计算机上，没有竞争的情况下获取并释放锁一般只需 20 纳秒。如果存在竞争，产生的上下文切换会把开销增加到微秒的级别，并且线程被重新调度前可能还会等待更久的时间。如果需要锁定的时间很短，那么可以使用【自旋锁（SpinLock）】来避免上下文切换的开销。

&emsp;&emsp;Monitor还提供了一个TryEnter方法，允许以毫秒或是TimeSpan方式指定超时时间。如果获得了锁，该方法会返回true，而如果由于超时没有获得锁，则会返回false。TryEnter也可以以无参数的形式进行调用，这是对锁进行“测试”，如果不能立即获得锁就会立即返回false。

>如果获取锁后保持的时间太长而不释放，就会降低并发度，同时也会加大【死锁】的风险。

### Mutex

Mutex互斥体类似于Monitor，不同在于它是可以跨越进程工作。换句话说，Mutex可以是机器范围（computer-wide）的，也可以是程序范围（application-wide）的。

>没有竞争的情况下，获取并释放Mutex需要几微秒的时间，大约比lock慢 50 倍。

&emsp;&emsp;使用Mutex类时，可以调用WaitOne方法来加锁，调用ReleaseMutex方法来解锁。关闭或销毁Mutex会自动释放锁。与lock语句一样，Mutex只能被获得该锁的线程释放。

跨进程Mutex的一种常见的应用就是确保只运行一个程序实例。
```c#
// 命名的 Mutex 是机器范围的，它的名称需要是唯一的
// 比如使用公司名+程序名，或者也可以用 URL
using (var mutex = new Mutex (false, "oreilly.com OneAtATimeDemo"))
{
  // 可能其它程序实例正在关闭，所以可以等待几秒来让其它实例完成关闭
  if (!mutex.WaitOne (TimeSpan.FromSeconds (3), false))
  {
    Console.WriteLine ("Another app instance is running. Bye!");
    return;
  }
  RunProgram();
}
```
>如果在终端服务（Terminal Services）下运行，机器范围的Mutex默认仅对于运行在相同终端会话的应用程序可见。要使其对所有终端会话可见，需要在其名字前加上Global\。


### 死锁

&emsp;&emsp;当两个线程等待的资源都被对方占用时（A等B，B等A），它们都无法执行，这就产生了死锁。更复杂的死锁链可能由三个或更多的线程创建。
```c#
object locker1 = new object();
object locker2 = new object();

new Thread(() =>
{
    lock (locker1)
    {
        Thread.Sleep(1000);
        lock (locker2)  // 死锁
        {
            // do something..
        }
    }
}).Start();

lock (locker2)
{
    Thread.Sleep(1000);
    lock (locker1)  // 死锁
    {
        // do something..
    }
}
```
&emsp;&emsp;CLR 不会像SQL Server一样自动检测和解决死锁。除非你指定了锁定的超时时间，否则死锁会造成参与的线程无限阻塞。（在SQL CLR 集成宿主环境中，死锁能够被自动检测，并在其中一个线程上抛出可捕获的异常。）

&emsp;&emsp;死锁是多线程中最难解决的问题之一，尤其是在有很多关联对象的时候。这个困难在根本上在于无法确定调用方（caller）已经拥有了哪些锁。

&emsp;&emsp;你可能会锁定类x中的私有字段a，而并不知道调用方（或者调用方的调用方）已经锁住了类y中的字段b。同时，另一个线程正在执行顺序相反的操作，这样就创建了死锁。讽刺的是，这个问题会由于（良好的）面向对象的设计模式而加剧，因为这类模式建立的调用链直到运行时才能确定。

&emsp;&emsp;流行的建议：“以一致的顺序对对象加锁以避免死锁”，尽管它对于我们最初的例子有帮助，但是很难应用到刚才所描述的场景。更好的策略是：如果发现在锁区域中的对其它类的方法调用最终会引用回当前对象，就应该小心，同时考虑是否真的需要对其它类的方法调用加锁（往往是需要的，但是有时也会有其它选择）。更多的依靠声明方式（declarative）与数据并行（data parallelism）、不可变类型（immutable types）与非阻塞同步构造（ nonblocking synchronization constructs），可以减少对锁的需要。

>有另一种思路：当你在拥有锁的情况下访问其它类的代码，对于锁的封装就存在潜在的泄露。这不是 CLR 或 .NET Framework 的问题，而是因为锁本身的局限性。某些人认为造成这样问题的根因是可重入？


## 信号构造

### Semaphore

信号量类似于一个通道：它具有一定的容量（capacity），并且有保安把守。一旦满员，就不允许其他人进入，这些人将在外面排队。当有一个人离开时，排在最前头的人便可以进入。

&emsp;&emsp;容量为1的的信号量就是一把互斥锁，类似mutex，不同的是信号量没有【所有者】，它是线程无关（thread-agnostic）的。任何线程都可以在调用Semaphore上的Release方法，而对于mutex，只有获得锁的线程才可以释放该锁。

>SemaphoreSlim是 standard1.0 就支持的轻量级的信号量，功能与Semaphore相似，不同之处是它对于并行编程的低延迟需求做了优化；支持在等待时指定取消标记 （cancellation token）。但它不能跨进程使用，Semaphore可以。
>
> 在Semaphore上调用WaitOne或Release会产生大概 1 微秒的开销（无竞争情况下），而SemaphoreSlim产生的开销约是其四分之一。


### ManualResetEvent

ManualResetEvent 调用WaitOne进入阻塞，任意可访问的线程都能调用Set方法来放行。
```c#
var waitHandle = new ManualResetEvent(false);
// var waitHandle = new EventWaitHandle(false, EventResetMode.ManualReset);
Task.Run(() =>
{
    _testOutputHelper.WriteLine(Thread.CurrentThread.ManagedThreadId + " 尝试进门...");
    waitHandle.WaitOne();
    _testOutputHelper.WriteLine(Thread.CurrentThread.ManagedThreadId + " 进去了");
    业务逻辑();
    _testOutputHelper.WriteLine("当前门的状态是开启的吗？"+waitHandle.WaitOne(0)); //true
});
Thread.Sleep(1000);
_testOutputHelper.WriteLine(Thread.CurrentThread.ManagedThreadId + " say：我来开门");
waitHandle.Set();
```

### AutoResetEvent
AutoResetEvent 如其命名，收到通知后他能自动复位（reset），而ManualResetEvent不能。

```c#
EventWaitHandle waitHandle = new AutoResetEvent(false);
 // var waitHandle2 = new EventWaitHandle(false, EventResetMode.AutoReset);
 Task.Factory.StartNew(() =>
 {
     _testOutputHelper.WriteLine(Thread.CurrentThread.ManagedThreadId + " 尝试进门...");
     waitHandle.WaitOne();
     _testOutputHelper.WriteLine(Thread.CurrentThread.ManagedThreadId + " 进去了");
     业务逻辑();
     _testOutputHelper.WriteLine("当前门的状态是开启的吗？"+waitHandle.WaitOne(0)); // false
     waitHandle.Set();
     Task.Run(() =>
     {
         waitHandle.WaitOne();  // 永远阻塞，直至主线程退出
         _testOutputHelper.WriteLine(Thread.CurrentThread.ManagedThreadId + " 进去了");
         业务逻辑();
     });
 });
 Thread.Sleep(1000);
 _testOutputHelper.WriteLine(Thread.CurrentThread.ManagedThreadId + " say：我来开门");
 waitHandle.Set();
 
 Thread.Sleep(1000); // 等待worker
```

> 从 Framework 4.0 开始，提供了另一个版本的ManualResetEvent，名为ManualResetEventSlim。
> 后者为短等待时间做了优化，它提供了进行一定次数迭代自旋的能力，也实现了一种更有效的管理机制，允许通过CancellationToken取消Wait等待。但它不能用于跨进程的信号同步。
> ManualResetEventSlim不是WaitHandle的子类，但它提供一个WaitHandle的属性，会返回一个基于WaitHandle的对象（使用它的性能和一般的等待句柄相同）。

EventWaitHandle的构造方法允许以命名的方式进行创建，这样它就可以跨进程使用。名称就是一个字符串，可以随意起名，但是注意不要和别人的命名冲突！如果名字在计算机上已存在，你就会获取一个它对应的EventWaitHandle的引用，否则操作系统会创建一个新的。

```c#
EventWaitHandle wh = new EventWaitHandle (false, EventResetMode.AutoReset,"MyCompany.MyApp.SomeName");
```
### CountdownEvent

CountdownEvent可以用于多线程等待，这个类型是 Framework 4.0 加入的，并且是一个高效的纯托管实现。

```c#
CountdownEvent _countdown = new CountdownEvent (3);

void 测试CountdownEvent等待()
{
    Task.Run(工作);
    Task.Run(工作);
    Task.Run(工作);

    _countdown.Wait();
    _testOutputHelper.WriteLine("大家都干完了");
}

void 工作()
{
    _testOutputHelper.WriteLine("干活");
    Thread.Sleep(1000);
    _countdown.Signal();
}
```
## 基本概念
**同步（synchronization）**：指对在一个系统中所发生的事件（event）之间进行协调，在时间上出现一致性与统一化的现象 -- 为期望的结果协调多个线程的行为。

当多个线程访问同一个数据时，同步尤为重要，但这是一件非常容易G的事情。

**同步对象（synchronized object）**：对所有参与同步的线程可见的任何对象都可以被当作同步对象使用，但有一个硬性规定：同步对象必须为引用类型。同步对象一般是私有的（因为这有助于封装锁逻辑）。

同步对象也可以就是其要保护的对象。
```c#
class ThreadSafe
{
  List <string> _list = new List <string>();

  void Test()
  {
    lock (_list)
    {
      _list.Add ("Item 1");
      // ...
```
一个只被用来加锁的字段可以精确控制锁的作用域与粒度。
```c#
private static readonly object _locker = new object();
```
对象自己（this），甚至是类型，lambda 表达式或匿名方法所捕获的局部变量 都可以被当作同步对象来使用：
```c#
lock (this) { ... }
// 或者：
lock (typeof (Widget)) { ... }    // 保护对静态资源的访问
```
但这种方式的缺点在于并没有对锁逻辑进行封装，从而很难避免【死锁】或过多的【阻塞】。 同时类型上的锁也可能会跨越应用程序域（application domain）边界（在同一进程内）。


**阻塞（block）**：当线程的执行由于某些原因被暂停，比如【信号构造】或【锁构造】时，比如调用Thread.Sleep，Task.Wait，或者通过Join方法等待其它线程结束时，则认为此线程被阻塞（blocked）。

阻塞会在以下 4 种情况下解除（电源按钮可不能算╮(╯▽╰)╭）：

* 阻塞条件被满足
* 操作超时（如果指定了超时时间）
* 通过Thread.Interrupt中断
* 通过Thread.Abort中止


编译器将async Task转换为状态机，到达 await 时暂停执行等待后台作业完成时继续执行。从理论上讲，这是[异步的承诺模型](https://en.wikipedia.org/wiki/Futures_and_promises)的实现。）
```c#
static async Task<Toast> MakeToastWithButterAndJamAsync(int number)
{
    // do samething..
    var toast = await ToastBreadAsync(number);
    // do samething..
    return toast;
}
```
**锁构造（lock）**：锁能够限制同一时刻可以执行某些指令或是某段代码的线程数量。排他锁是最常见的，它只允许同一时刻至多有一个线程执行，从而可以使得参与竞争的线程在访问公共数据时不会彼此干扰。
一般的排他锁有lock（Monitor.Enter/Monitor.Exit）、Mutex、SpinLock，非排他锁有Semaphore、SemaphoreSlim以及reader/writer lock。

**信号构造（signal）**：信号构造可以使一个线程【挂起】，直到接收到另一个线程的通知，避免了低效的轮询 。有两种经常使用的信号设施：事件等待句柄（event wait handle ）和Monitor类的Wait / Pulse方法。
Framework 4.0 加入了CountdownEvent与Barrier类。

**自旋（spinning）**：有时线程必须阻塞/暂停，直至条件被满足，【信号构造】或【锁构造】可以实现，但在等待条件能够在微秒级的时间被满足时，
自旋往往更加高效，因为它避免了上下文切换带来的昂贵开销。
```c#
while (!condition);
```
自旋往往与阻塞组合使用，防止cpu浪费
```c#
while (!condition) Thread.Sleep (10);
```
**线程状态（thread state）**：Unstarted、Running、WaitSleepJoin、Stopped。。

### Atomically

**指令原子性（instruction atomically）**：如果一条【指令】可以在 CPU 上不可分割地执行，那么它就是原子的

**原子性（atomically）**：如果一组变量总是在相同的锁内进行读写，就可以称为原子性读写
```c#
lock (locker) { if (x != 0) y /= x; }
```
可以说x和y是被原子的访问的，因为上面的代码块无法被其它的线程分割或抢占（cpu悲观锁/总线锁）。如果被其它线程分割或抢占，x和y就可能被别的线程修改导致计算结果无效（cpu乐观锁/缓存锁）。而现在 x和y总是在相同的排它锁中进行访问，因此不会出现除数为零的错误。

如果lock代码块内发生异常，原子性将被打破
```c#
decimal _savingsBalance, _checkBalance;

void Transfer (decimal amount)
{
  lock (_locker)
  {
    _savingsBalance += amount;
    _checkBalance -= amount + GetBankFee();
  }
}
```
如果GetBankFee()方法内抛出异常，银行可能就要亏钱了。在这个例子中，我们可以通过更早的调用GetBankFee()来避免这个问题。对于更复杂情况，解决方案是在catch或finally中实现“回滚（rollback）”逻辑。


## 线程安全

**线程安全（thread safe）**：指的是被任意多的线程同时执行，都可以保证正确性。

>除基本类型外，很少有类型是线程安全的，线程安全的责任基本落在开发者身上，System.Collections.Concurrent命名空间下的类型的除外。

* 线程安全最常见的手段一般是使用【**排它锁**】，将大段代码甚至是访问的整个对象封装在一个排它锁内，从而保证在高层上能进行顺序访问。
这种解决方案适用于对象的方法都能够快速执行的场景（否则会导致大量的阻塞）。
* 还有一种手段很高明，即通过【**最小化共享数据**】来减少【线程交互】，web服务器就是最好的案例，由于多个客户端请求可以同时到达，服务端方法必须保证线程安全。类似的案例还有【无状态】设计，在本质上限制了
数据交互的可能，具有良好的伸缩性（scalability）。
* 还有一种手段，【**自动锁机制（automatic locking）**】如果继承 ContextBoundObject 类并使用 Synchronization 特性，.NET Framework 就可以实现这种机制，framework全系支持，但是netcore没有，类似java的synchronized。
>尽管这样降低了开发者实现线程安全的负担，但范围过大的锁定作用域将制造出巨大的麻烦：死锁、非有意的重入以及降低并发度。这使得手动锁定在任何场景都显得更为合适，而并不仅仅只在简单的场景下（直到有更好用的自动锁机制出现）。
* 其它手段，【信号构造】，【内存屏障】，【自旋构造】。。。


### 前言

在前三章中我们的案例大量使用到了`Thread`这个类，通过其原始API，对其进行创建、启动、中断、中断、终止、取消以及异常处理，这样的写法不仅不够优雅（对接下来这篇，我称其为`.NET现代化并行编程体系`中出现的API而言），并且大部分的接口都是极度复杂和危险的。很幸运，如今.NET已经提供，并且普及了一系列多线程API来帮助我们，优雅且安全的达到相同的目的。

其中，`Parallel`和`Task`被一起称为TPL（Task Parallel Library，任务并行库），而这对双子星也就是我们本章的主题。如果您对线程基础、并行原理不是很了解，我还是强烈建议先学习前面的章节，万丈高楼平地起是前提是地基打的足够结实！

## 一、PFX

Parallel Framework，并行框架：用于并行编程，帮助你充分利用CPU的多个核心。

![](./images/PFX.png)

其中`PLINQ`提供最丰富的功能：它能够自动化并行所有步骤--包括工作分解，多线程执行，并整理结果输出一个序列。它是声明式（declarative）的--你只需构造一个`Linq`，然后由框架来帮你完成剩下的工作。

`Parallel`和`Task`是指令式（imperative）的--你需要自己编写代码来整理结果，甚至分解工作。

|                                                              | Partitions work | Collates results |
| :----------------------------------------------------------- | :-------------- | :--------------- |
| [PLINQ](https://www.albahari.com/threading/part5.aspx#_PLINQ) | Yes             | Yes              |
| The `Parallel` class                                         | Yes             | No               |
| PFX’s [task parallelism](https://www.albahari.com/threading/part5.aspx#_Task_Parallelism) | No              | No               |

瘦信号`Slim Signaling` 和 延迟初始化`Lazy Initialization`我们已经在前面的章节中讲过了，并发集合`Concurrent Collections` 和 自旋基元`Spinning Primitives`事实上我们也模拟过，在本章会进一步来讲。

> 这里可能要解释一下什么是结构化：一切有条不紊、充满合理逻辑和准则的。
>
> 在早期使用汇编编程时，为了更加契合计算机运行的实际状况，控制流分为“顺序执行”和“跳转”，这里的跳转也就是著名的--goto，无条件跳转可能会使得代码运行杂乱无章，不可预测。Dijkstra著名的goto有害论的中翻地址：https://www.emon100.com/goto-translation/

### 一个定律

阿姆达尔定律 Amdahl's law，指出了固定负载（必须顺序执行的部分）情况下，处理器并行运算的最大性能提升
$$
假设处理器个数为n，可并行部分为w，则加速比s = 1 / ((1 - w) + w / n)
$$
讨论：

$$
当固定负载(1-w)\to 0，即w\to 1时几乎没有串行部分，加速比s\to n
$$

$$
当可并行部分w\to 0时几乎没有可并行部分，加速比s\to 1，此时无论加多少处理器也没啥效果
$$

$$
当处理器个数n\to \infty时，加速比s\to 1 / (1 - w)，这也是加速比上限
$$

综上：
$$
加速比s取决于可并行部分w或串行部分1-w，即s = 1 / 串行占比
$$

### 两个密集

1. **CPU密集型（CPU-bound）**

   ​	也叫计算密集型，指的是系统的硬盘、内存性能相对CPU要好很多，此时，系统运作CPU读写IO(硬盘/内存)时，IO可以在很短的时间内完成，而CPU还有许多运算要处理，因此，CPU负载很高。

   ​	CPU密集表示该任务需要大量的运算，而没有阻塞，CPU一直全速运行。CPU密集任务只有在真正的多核CPU上才可能得到加速（通过多线程），通常，线程数只需要设置为CPU核心数的线程个数就可以了。而在单核CPU上，无论你开几个模拟的多线程该任务都不可能得到加速比，因为CPU总的运算能力就只有这么多。

2. **IO密集型（I/O bound）**

   ​	IO密集型指的是系统的CPU性能相对硬盘、内存要好很多，此时，系统运作，大部分的状况是CPU在等IO (硬盘/内存) 的读写操作，因此，CPU负载并不高。

   ​	IO密集型的程序一般在达到性能极限时，CPU占用率仍然较低。这可能是因为任务本身需要大量I/O操作，而程序的逻辑做得不是很好，没有充分利用处理器能力。通常就需要开CPU核心数数倍的线程。

3. **CPU密集型 vs IO密集型**

   ​	CPU密集型任务的特点就是需要进行大量计算（例如:计算圆周率、对视频进行高清解码、矩阵运算等情况）。 这一情况多出现在一些业务复杂的计算和逻辑处理过程中。比如说，现在的一些机器学习和深度学习的模型训练和推理任务，包含了大量的矩阵运算。

   ​	IO密集型任务一般涉及到网络、磁盘IO，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用。

   

### 使用场景

使用`PFX`前需要检查是否真的有必要并行，经过对阿姆达尔定律的了解，我们可以看出，并非使用更多的处理器，性能就能随之水涨船高。如果顺序执行的代码段占了这个工作的三分之二，即使用无数核心，也无法获得哪怕0.5倍的性能提升。

在并行中有可以分为两大类

- 结构化并行：如果一个工作可以很容易被分解成多个任务，每个任务都能独立高效的执行，那么结构化并行无疑是非常合适的，例如图片处理，光线追踪，密码暴力破解等。

- 非结构化并行：比方说多线程快排，我们可能需要自己拆解任务然后收集结果

  https://cloud.tencent.com/developer/article/1560871

  https://github.com/stephen-wang/parallel_quick_sort

> 对于图像处理来说 PLINQ 是个糟糕的选择，因为整理几百万个像素到输出序列将形成瓶颈。更好的方法是把像素直接写入数组或非托管的内存块，然后使用`Parallel`类或`Task`来管理多线程也可以使用`ForAll`来绕过结果整理。



## 二、PINQ

PLINQ就是Parallel LNQ，熟悉LNQ的小伙伴几乎没有额外的学习成本。

只需要在集合后面加个`AsParallel()`，就可以像平时写LNQ一样继续使用了，Framework会自动的进行工作分解，然后调用核心执行任务，最终将各个核心的结果整理并返回给你。

![](./images/PFX-AsParallel.png)

下面的例子利用PLINQ查询3到100,000内的所有素数

> 注意：这一部分提供的所有代码都可以在 LINQPad 中试验。

```c#
IEnumerable<int> numbers = Enumerable.Range(3, 100000 - 3);
var parallelQuery =
    from n in numbers.AsParallel()
    where Enumerable.Range(2, (int)Math.Sqrt(n)).All(i => n % i > 0)
    select n;
int[] primes = parallelQuery.ToArray();
```

当然你也可以

```c#
var parallelQuery = numbers.AsParallel().Where(x => Enumerable.Range(2, (int)Math.Sqrt(x)).All(i => x % i > 0));
```

但一定不要，先操作再分区等于分了个寂寞

```c#
var parallelQuery = numbers.Where(x => Enumerable.Range(2, (int)Math.Sqrt(x)).All(i => x % i > 0)).AsParallel();
```

这里我不再过多讨论语法上的东西，大家自己多尝试。

注意事项：

- PLINQ仅适用于本地集合
- 查询过程中各个分区产生的异常会封送到`AggregateException`然后重新抛出
- 默认情况下是无序的，但可以使用`AsOrdered`有序，但是性能也会有所消耗
- 执行过程必须是线程安全的，否则结果不可靠
- 并行化过程的任务分区，结果整理，以及线程开辟和管理都需要成本
- 如果它认为并行化是没有必要的，会使查询更慢的，会转为顺序执行
- 默认情况下，PLINQ总会认为你执行的是CPU Bound，然后开启核心数个任务

### 缓冲行为

PLINQ和LINQ一样，也是延迟查询。不同的是，

LINQ完全由使用方通过“拉”的方式驱动：每个元素都在使用方需要时从序列中被提取。

而PLINQ通常使用独立的线程从序列中提取元素，然后通过查询链并行处理这些元素，将结果保存在一个小缓冲区中，以准备在需要的时候提供给使用方。如果使用方在枚举过程中暂停或中断，查询也会暂停或停止，这样可以不浪费 CPU 时间或内存。

你可以通过在`AsParallel`之后调用`WithMergeOptions`来调整 PLINQ 的缓冲行为，`ParallelMergeOptions`有以下几种模式

- Default，默认使用AutoBuffered通常能产生最佳的整体效果
- NoBuffered，禁用缓冲，一旦计算出结果，该元素即对查询的使用者可用
- AutoBuffered，由系统选择缓冲区大小，结果会在可供使用前输出到缓冲区
- FullyBuffered，完全缓冲，使用时可以得到全部计算结果（`OrderBy`,`Reverse`）。

### 顺序性

PLINQ的结果默认就是无序的，无法像LINQ那样保证输出顺序与输入顺序一致。如果你希望保持一致，可以在`AsParallel()`后添加`AsOrdered()`

```c#
var parallelQuery =
    from n in numbers.AsParallel().AsOrdered()
    where Enumerable.Range(2, (int)Math.Sqrt(n)).All(i => n % i > 0)
    select n;
```

如何序列元素过多，`AsOrdered`会造成一定性能损失，因为 PLINQ 必须跟踪每个元素的原始位置。你可以通过`AsUnordered`来取消`AsOrdered`的效果：这会引入一个“随机洗牌点（random shuffle point）”，允许查询从这里开始不再跟踪。

### 限制

目前，PLINQ 在能够并行化的操作上有些实用性限制。

1. `Aggregate`操作符的带种子（seed）的重载是不能并行化的，`ForAll`可以解决这个问题。

   其它所有操作符都是可以并行化的，然而使用这些操作符并不能确保你的查询会被并行化。

2. 默认情况PLINQ 将检查查询的结构，并且只有在可能导致加速的情况下才会并行化查询。 如果查询结构表明不可能获得加速比，则 PLINQ 将执行查询作为普通的 LINQ to Objects 查询。你可以覆盖这个默认行为，强制开启并行化：

   ```c#
   AsParallel().WithExecutionMode(ParallelExecutionMode.ForceParallelism)
   ```


3. 对于那些接受两个输入序列的查询操作符，必须在这两个序列必须都是`ParallelQuery`（否则将抛出异常）

  - `Join`、`GroupJoin`、`Contact`、`Union`、`Intersect`、`Except`和`Zip`
  - 这些操作可以并行化，但会使用代价高昂的**散列分区（Hash partitioning）**，有时可能比顺序执行还慢。
4. 大多数查询操作都会改变元素的索引位置（包括可能移除元素的那些操作，例如`Where`）。这意味着如果你希望使用这些操作，就要在查询开始的地方使用。
5. PLINQ会并行的在多个线程上运行，不要执行非线程安全的操作。虽然可以使用前面讲过的同步构造来解决线程安全问题，但是为了达到最佳性能，确保并行能力不会受到限制。

### CPU密集型案例

在这个案例中我们下载了约 150,000 个单词放到`HashSet`中

```c#
if (!File.Exists("WordLookup.txt")) // 包含约 150,000 个单词
{
    var res = new HttpClient().GetByteArrayAsync(new Uri("http://www.albahari.com/ispell/allw
        .GetAwaiter().GetResult();
    File.WriteAllBytes("WordLookup.txt", res);
}
var wordLookup = new HashSet<string>(
    File.ReadAllLines("WordLookup.txt"),
    StringComparer.InvariantCultureIgnoreCase);
```

然后随机生成一份100,0000万单词的测试数据，由于是并行生成，随机需要考虑线程安全

```c#
string[] wordList = wordLookup.ToArray();

var localRandom = new ThreadLocal<Random>
    ( () => new Random (Guid.NewGuid().GetHashCode()) );
string[] wordsToTest = Enumerable.Range(0, 100_0000).AsParallel()
    .Select(i => wordList[localRandom.Value.Next(0, wordList.Length)])
    .ToArray();

wordsToTest[12345] = "woozsh"; // 引入两个拼写错误
wordsToTest[23456] = "wubsie";
```

现在，根据`workLookup`检查每一个测试数据，最后输出检查到的错误拼写

```c#
var query = wordsToTest
    .AsParallel()
    .Select((word, index) => new IndexedWord { Word = word, Index = index })
    .Where(iword => !wordLookup.Contains(iword.Word))
    .OrderBy(iword => iword.Index);
//query.Dump();     // 在 LINQPad 中显示输出
foreach (var item in query)
{
    _testOutputHelper.WriteLine($"单词：{item.Word} 拼写错误，索引：{item.Index}");
}
```

其中`IndexedWord`是一个自定义的结构体。

```c#
struct IndexedWord { public string Word; public int Index; }
```

> 使用类也能获得相同的结果，但是性能会有所下降。因为类是引用类型，在堆中分配，只后还有垃圾回收。
>
> 这个区别对LINQ而言影响并不是很大，但对于PLNQ而言，基于栈的内存分配相当有利。因为每个线程都有自己的独立栈，可以高度并行化，而堆内存会使多个线程竞争同一个堆（竞态），它是由单一的内存管理器和垃圾回收器管理的。

输出，成功的找到了刚刚故意引入拼写错误的两个单词

```shell
单词：woozsh 拼写错误，索引：12345
单词：wubsie 拼写错误，索引：23456
```

### IO密集型案例

这个案例中我们希望同时ping 2个网站，如果我们运行在的是一个单核机器上，PLINQ 只会默认运行 1 个任务，显然这不是我们希望的。

我们可以使用`WithDegreeOfParallelism`强制 PLINQ 同时运行指定数量的任务：

> 注意，PLINQ 切分的任务是由线程池线程执行，线程池的线程并不是取之不尽用之不竭的，具体在下一part讲。

```c#
new[]
    {
        "www.oreilly.com",
        "stackoverflow.com",
    }
    .AsParallel().WithDegreeOfParallelism(2).Select(site =>
    {
        var p = new Ping().Send(site);
        return new
        {
            site,
            Result = p.Status,
            Time = p.RoundtripTime
        };
    }).ForAll(res =>
    {
        _testOutputHelper.WriteLine(res.site + $" coast {res.Time}:" + res.Result);
    });
```

输出：

```shell
stackoverflow.com coast 173ms : Success
www.oreilly.com coast 219ms : Success
```

再给一个例子：假设我们要实现一个监控系统，希望它不断将来自 4 个安全摄像头的图像合并成一个图像，并在闭路电视上显示。使用下边的`Camera`类来表示一个摄像头：

```c#
class Camera
{
    public readonly int CameraID;

    public Camera(int cameraID)
    {
        CameraID = cameraID;
    }

    // 获取来自摄像头的图像: 返回一个字符串来代替图像
    public string GetNextFrame()
    {
        Thread.Sleep(123); // 模拟获取图像的时间，真实情况下这部分应该是IO密集操作
        return "Frame from camera " + CameraID;
    }
}
```

要获取一个合成图像，我们必须分别在 4 个摄像头对象上调用`GetNextFrame`。假设操作主要是受 I/O 影响的，即使是在单核机器上，通过并行化我们都能将帧率提升 4 倍。

```c#
Camera[] cameras = Enumerable.Range(0, 4) // 创建 4 个摄像头对象
    .Select(i => new Camera(i))
    .ToArray();
while (true)
{
    string[] data = cameras
    	.AsParallel()
    	.AsOrdered()  // 这里这有四个元素，追踪的成本几乎可以忽略不计算
    	.WithDegreeOfParallelism(4)
    	.Select(c => c.GetNextFrame()).ToArray();
    _testOutputHelper.WriteLine(string.Join(", ", data)); // 显示数据...
}
```

> 在一个 PLINQ 中，仅能调用`WithDegreeOfParallelism`一次。如果你需要再次调用它，必须再次调用`AsParallel()`强制进行查询的合并和重新分区

### 取消

`Parallel`切分多个任务，将任务交由线程池线程处理，线程池的任务是支持取消令牌（安全取消协作模式），`Parallel`同理支持`CancellationToken`。我们使用之前使用的找PLINQ 素数案例，然后起一个任务，在2ms后取消。

```c#
IEnumerable<int> numbers = Enumerable.Range(3, 1000000 - 3);
var cancelSource = new CancellationTokenSource();
var parallelQuery = numbers
    .AsParallel()
    //.WithMergeOptions(ParallelMergeOptions.FullyBuffered)
    .WithCancellation(cancelSource.Token)
    .Where(x => Enumerable.Range(2, (int)Math.Sqrt(x)).All(i => x % i > 0));
Task.Run(() => { Thread.Sleep(2); cancelSource.Cancel(); });
```

下面是消费者代码，为了防止打印太多，我们间隔500个打印一次

```c#
try
{
    int cnt = 0;
    foreach (var prime in parallelQuery)
    {
        if (cnt % 500 == 0) _testOutputHelper.WriteLine(prime.ToString());
        cnt++;
    }
}
catch (OperationCanceledException e)
{
    _testOutputHelper.WriteLine("工作已经被取消");
}
```

结果是打印了一些后抛出`OperationCanceledException`

```c#
23
9341
12941
16879
...
工作已经被取消
```

> PLINQ 不会直接中止线程，因为这么做是危险的。在取消时，它会等待所有工作线程处理完当前的元素，然后才抛出`OperationCanceledException` 结束查询。
>
> 接下来我们会大量出现这种模式，这也是受益PFX设计保持高度一致。